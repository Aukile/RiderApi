package net.ankrya.rider_api.init.assist;

import net.minecraft.commands.synchronization.ArgumentTypeInfo;
import net.minecraft.core.particles.ParticleType;
import net.minecraft.network.chat.ChatType;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.sounds.SoundEvent;
import net.minecraft.stats.StatType;
import net.minecraft.util.valueproviders.FloatProviderType;
import net.minecraft.util.valueproviders.IntProviderType;
import net.minecraft.world.damagesource.DamageType;
import net.minecraft.world.effect.MobEffect;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.ai.attributes.Attribute;
import net.minecraft.world.entity.ai.memory.MemoryModuleType;
import net.minecraft.world.entity.ai.sensing.SensorType;
import net.minecraft.world.entity.ai.village.poi.PoiType;
import net.minecraft.world.entity.animal.CatVariant;
import net.minecraft.world.entity.animal.FrogVariant;
import net.minecraft.world.entity.decoration.PaintingVariant;
import net.minecraft.world.entity.npc.VillagerProfession;
import net.minecraft.world.entity.npc.VillagerType;
import net.minecraft.world.entity.schedule.Activity;
import net.minecraft.world.entity.schedule.Schedule;
import net.minecraft.world.inventory.MenuType;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Instrument;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.alchemy.Potion;
import net.minecraft.world.item.armortrim.TrimMaterial;
import net.minecraft.world.item.armortrim.TrimPattern;
import net.minecraft.world.item.crafting.RecipeSerializer;
import net.minecraft.world.item.crafting.RecipeType;
import net.minecraft.world.item.enchantment.Enchantment;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.biome.Biome;
import net.minecraft.world.level.biome.BiomeSource;
import net.minecraft.world.level.biome.MultiNoiseBiomeSourceParameterList;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.entity.BannerPattern;
import net.minecraft.world.level.block.entity.BlockEntityType;
import net.minecraft.world.level.chunk.ChunkGenerator;
import net.minecraft.world.level.chunk.ChunkStatus;
import net.minecraft.world.level.dimension.DimensionType;
import net.minecraft.world.level.dimension.LevelStem;
import net.minecraft.world.level.gameevent.GameEvent;
import net.minecraft.world.level.gameevent.PositionSourceType;
import net.minecraft.world.level.levelgen.DensityFunction;
import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
import net.minecraft.world.level.levelgen.SurfaceRules;
import net.minecraft.world.level.levelgen.blockpredicates.BlockPredicateType;
import net.minecraft.world.level.levelgen.carver.ConfiguredWorldCarver;
import net.minecraft.world.level.levelgen.carver.WorldCarver;
import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
import net.minecraft.world.level.levelgen.feature.Feature;
import net.minecraft.world.level.levelgen.feature.featuresize.FeatureSizeType;
import net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacerType;
import net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacerType;
import net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType;
import net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecoratorType;
import net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacerType;
import net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorPreset;
import net.minecraft.world.level.levelgen.heightproviders.HeightProviderType;
import net.minecraft.world.level.levelgen.placement.PlacedFeature;
import net.minecraft.world.level.levelgen.placement.PlacementModifierType;
import net.minecraft.world.level.levelgen.presets.WorldPreset;
import net.minecraft.world.level.levelgen.structure.Structure;
import net.minecraft.world.level.levelgen.structure.StructureSet;
import net.minecraft.world.level.levelgen.structure.StructureType;
import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
import net.minecraft.world.level.levelgen.structure.placement.StructurePlacementType;
import net.minecraft.world.level.levelgen.structure.pools.StructurePoolElementType;
import net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool;
import net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTestType;
import net.minecraft.world.level.levelgen.structure.templatesystem.RuleTestType;
import net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorList;
import net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessorType;
import net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.RuleBlockEntityModifierType;
import net.minecraft.world.level.levelgen.synth.NormalNoise;
import net.minecraft.world.level.material.Fluid;
import net.minecraft.world.level.storage.loot.entries.LootPoolEntryType;
import net.minecraft.world.level.storage.loot.functions.LootItemFunctionType;
import net.minecraft.world.level.storage.loot.predicates.LootItemConditionType;
import net.minecraft.world.level.storage.loot.providers.nbt.LootNbtProviderType;
import net.minecraft.world.level.storage.loot.providers.number.LootNumberProviderType;
import net.minecraft.world.level.storage.loot.providers.score.LootScoreProviderType;
import net.minecraftforge.registries.DeferredRegister;
import org.jetbrains.annotations.ApiStatus;

import java.util.Locale;
import java.util.Map;

/**不要看我啦~*/
@ApiStatus.Internal
public final class RegisterAssist {

    public static String getRegisterName(Class<?> type) {
        if (Activity.class.isAssignableFrom(type)) return "activity";
        else if (Attribute.class.isAssignableFrom(type)) return "attribute";
        else if (BannerPattern.class.isAssignableFrom(type)) return "banner_pattern";
        else if (BiomeSource.class.isAssignableFrom(type)) return "worldgen/biome_source";
        else if (Block.class.isAssignableFrom(type)) return "block";
        else if (BlockEntityType.class.isAssignableFrom(type)) return "block_entity_type";
        else if (BlockPredicateType.class.isAssignableFrom(type)) return "block_predicate_type";
        else if (BlockStateProviderType.class.isAssignableFrom(type)) return "worldgen/block_state_provider_type";
        else if (WorldCarver.class.isAssignableFrom(type)) return "worldgen/carver";
        else if (CatVariant.class.isAssignableFrom(type)) return "cat_variant";
        else if (ChunkGenerator.class.isAssignableFrom(type)) return "worldgen/chunk_generator";
        else if (ChunkStatus.class.isAssignableFrom(type)) return "chunk_status";
        else if (ArgumentTypeInfo.class.isAssignableFrom(type)) return "command_argument_type";
        else if (CreativeModeTab.class.isAssignableFrom(type)) return "creative_mode_tab";
        else if (ResourceLocation.class.isAssignableFrom(type)) return "custom_stat";
        else if (DamageType.class.isAssignableFrom(type)) return "damage_type";
        else if (DensityFunction.class.isAssignableFrom(type)) return "worldgen/density_function_type";
        else if (Enchantment.class.isAssignableFrom(type)) return "enchantment";
        else if (EntityType.class.isAssignableFrom(type)) return "entity_type";
        else if (Feature.class.isAssignableFrom(type)) return "worldgen/feature";
        else if (FeatureSizeType.class.isAssignableFrom(type)) return "worldgen/feature_size_type";
        else if (FloatProviderType.class.isAssignableFrom(type)) return "float_provider_type";
        else if (Fluid.class.isAssignableFrom(type)) return "fluid";
        else if (FoliagePlacerType.class.isAssignableFrom(type)) return "worldgen/foliage_placer_type";
        else if (FrogVariant.class.isAssignableFrom(type)) return "frog_variant";
        else if (GameEvent.class.isAssignableFrom(type)) return "game_event";
        else if (HeightProviderType.class.isAssignableFrom(type)) return "height_provider_type";
        else if (Instrument.class.isAssignableFrom(type)) return "instrument";
        else if (IntProviderType.class.isAssignableFrom(type)) return "int_provider_type";
        else if (Item.class.isAssignableFrom(type)) return "item";
        else if (LootItemConditionType.class.isAssignableFrom(type)) return "loot_condition_type";
        else if (LootItemFunctionType.class.isAssignableFrom(type)) return "loot_function_type";
        else if (LootNbtProviderType.class.isAssignableFrom(type)) return "loot_nbt_provider_type";
        else if (LootNumberProviderType.class.isAssignableFrom(type)) return "loot_number_provider_type";
        else if (LootPoolEntryType.class.isAssignableFrom(type)) return "loot_pool_entry_type";
        else if (LootScoreProviderType.class.isAssignableFrom(type)) return "loot_score_provider_type";
        else if (SurfaceRules.ConditionSource.class.isAssignableFrom(type)) return "worldgen/material_condition";
        else if (SurfaceRules.RuleSource.class.isAssignableFrom(type)) return "worldgen/material_rule";
        else if (MemoryModuleType.class.isAssignableFrom(type)) return "memory_module_type";
        else if (MenuType.class.isAssignableFrom(type)) return "menu";
        else if (MobEffect.class.isAssignableFrom(type)) return "mob_effect";
        else if (PaintingVariant.class.isAssignableFrom(type)) return "painting_variant";
        else if (ParticleType.class.isAssignableFrom(type)) return "particle_type";
        else if (PlacementModifierType.class.isAssignableFrom(type)) return "worldgen/placement_modifier_type";
        else if (PoiType.class.isAssignableFrom(type)) return "point_of_interest_type";
        else if (PositionSourceType.class.isAssignableFrom(type)) return "position_source_type";
        else if (PosRuleTestType.class.isAssignableFrom(type)) return "pos_rule_test";
        else if (Potion.class.isAssignableFrom(type)) return "potion";
        else if (RecipeSerializer.class.isAssignableFrom(type)) return "recipe_serializer";
        else if (RecipeType.class.isAssignableFrom(type)) return "recipe_type";
        else if (RootPlacerType.class.isAssignableFrom(type)) return "worldgen/root_placer_type";
        else if (RuleTestType.class.isAssignableFrom(type)) return "rule_test";
        else if (RuleBlockEntityModifierType.class.isAssignableFrom(type)) return "rule_block_entity_modifier";
        else if (Schedule.class.isAssignableFrom(type)) return "schedule";
        else if (SensorType.class.isAssignableFrom(type)) return "sensor_type";
        else if (SoundEvent.class.isAssignableFrom(type)) return "sound_event";
        else if (StatType.class.isAssignableFrom(type)) return "stat_type";
        else if (StructurePieceType.class.isAssignableFrom(type)) return "worldgen/structure_piece";
        else if (StructurePlacementType.class.isAssignableFrom(type)) return "worldgen/structure_placement";
        else if (StructurePoolElementType.class.isAssignableFrom(type)) return "worldgen/structure_pool_element";
        else if (StructureProcessorType.class.isAssignableFrom(type)) return "worldgen/structure_processor";
        else if (StructureType.class.isAssignableFrom(type)) return "worldgen/structure_type";
        else if (TreeDecoratorType.class.isAssignableFrom(type)) return "worldgen/tree_decorator_type";
        else if (TrunkPlacerType.class.isAssignableFrom(type)) return "worldgen/trunk_placer_type";
        else if (VillagerProfession.class.isAssignableFrom(type)) return "villager_profession";
        else if (VillagerType.class.isAssignableFrom(type)) return "villager_type";
        else if (String.class.isAssignableFrom(type)) return "decorated_pot_patterns";
        else if (Biome.class.isAssignableFrom(type)) return "worldgen/biome";
        else if (ChatType.class.isAssignableFrom(type)) return "chat_type";
        else if (ConfiguredWorldCarver.class.isAssignableFrom(type)) return "worldgen/configured_carver";
        else if (ConfiguredFeature.class.isAssignableFrom(type)) return "worldgen/configured_feature";
        else if (DensityFunction.class.isAssignableFrom(type)) return "worldgen/density_function";
        else if (DimensionType.class.isAssignableFrom(type)) return "dimension_type";
        else if (FlatLevelGeneratorPreset.class.isAssignableFrom(type)) return "worldgen/flat_level_generator_preset";
        else if (NoiseGeneratorSettings.class.isAssignableFrom(type)) return "worldgen/noise_settings";
        else if (NormalNoise.NoiseParameters.class.isAssignableFrom(type)) return "worldgen/noise";
        else if (PlacedFeature.class.isAssignableFrom(type)) return "worldgen/placed_feature";
        else if (Structure.class.isAssignableFrom(type)) return "worldgen/structure";
        else if (StructureProcessorList.class.isAssignableFrom(type)) return "worldgen/processor_list";
        else if (StructureSet.class.isAssignableFrom(type)) return "worldgen/structure_set";
        else if (StructureTemplatePool.class.isAssignableFrom(type)) return "worldgen/template_pool";
        else if (TrimMaterial.class.isAssignableFrom(type)) return "trim_material";
        else if (TrimPattern.class.isAssignableFrom(type)) return "trim_pattern";
        else if (WorldPreset.class.isAssignableFrom(type)) return "worldgen/world_preset";
        else if (MultiNoiseBiomeSourceParameterList.class.isAssignableFrom(type)) return "worldgen/multi_noise_biome_source_parameter_list";
        else if (Level.class.isAssignableFrom(type)) return "dimension";
        else if (LevelStem.class.isAssignableFrom(type)) return "dimension";
        else return type.getSimpleName().toLowerCase(Locale.ROOT);
    }

    public static boolean registerSourceSafe(Class<?> type, Map<Class<?>, DeferredRegister<?>> registerMap){
        boolean safe = true;
        for (Class<?> clazz : registerMap.keySet()){
            if (clazz == type || clazz.getName().equals(type.getName()) || clazz.isAssignableFrom(type)) {
                safe = false;
                break;
            }
        }
        return safe;
    }
}
